After analyzing the provided IR code, I extracted the call graph and represented it in the dot file format. Here is the output:

```
digraph call_graph {
    node[shape=box, style=filled];

    "_Z7any_intfff"[label="_Z7any_intfff"];
    "llvm.round.f32"[label="llvm.round.f32"];

    "_Z7any_intfff" -> "llvm.round.f32"[label="call"];
    "_Z7any_intfff" -> "llvm.round.f32"[label="call"];
    "_Z7any_intfff" -> "llvm.round.f32"[label="call"];
}
```

In this call graph, we have two nodes: `_Z7any_intfff` and `llvm.round.f32`. The node `_Z7any_intfff` represents the function with the same name, and the node `llvm.round.f32` represents the `llvm.round.f32` function.

There are three edges from `_Z7any_intfff` to `llvm.round.f32`, indicating that the function `_Z7any_intfff` calls `llvm.round.f32` three times.

Note that the basic block information is not included in this call graph, as per your request. Only the function-level call relationships are represented.