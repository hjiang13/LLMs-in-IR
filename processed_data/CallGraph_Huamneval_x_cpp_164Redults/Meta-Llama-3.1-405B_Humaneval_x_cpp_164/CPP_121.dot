After analyzing the provided IR code, I extracted the call graph and represented it in the dot file format. Here is the output:

```
digraph call_graph {
    node[shape=box];
    edge[dir=back];

    node_0[label="%1"];
    node_1[label="%10"];
    node_2[label="%17"];
    node_3[label="%20"];
    node_4[label="%66"];
    node_5[label="%70"];
    node_6[label="%74"];
    node_7[label="%76"];
    node_8[label="@llvm.umax.i64"];
    node_9[label="@llvm.vector.reduce.add.v4i32"];

    node_0 -> node_1;
    node_0 -> node_6;
    node_1 -> node_2;
    node_1 -> node_5;
    node_2 -> node_3;
    node_3 -> node_3;
    node_3 -> node_4;
    node_4 -> node_6;
    node_4 -> node_5;
    node_5 -> node_7;
    node_6 -> node_7;
    node_7 -> node_6;
    node_3 -> node_8;
    node_4 -> node_9;
}
```

Note that the node labels correspond to the basic block labels in the IR code, and the edges represent the control flow between the basic blocks. The `@llvm.umax.i64` and `@llvm.vector.reduce.add.v4i32` nodes represent the external function calls.