After analyzing the provided IR code, I've constructed the call graph. Since there is only one function in the provided code, the call graph is quite simple. Here is the output in dot file format:

```
digraph CallGraph {
    node[shape=box];
    "_Z15smallest_changeSt6vectorIiSaIiEE" [label="_Z15smallest_changeSt6vectorIiSaIiEE"];
    "_Z15smallest_changeSt6vectorIiSaIiEE" -> "_Z15smallest_changeSt6vectorIiSaIiEE" [label="14 -> 14 (loop)"];
    "_Z15smallest_changeSt6vectorIiSaIiEE" -> "_Z15smallest_changeSt6vectorIiSaIiEE" [label="14 -> 12"];
    "_Z15smallest_changeSt6vectorIiSaIiEE" -> "_Z15smallest_changeSt6vectorIiSaIiEE" [label="1 -> 14"];
    "_Z15smallest_changeSt6vectorIiSaIiEE" -> "_Z15smallest_changeSt6vectorIiSaIiEE" [label="1 -> 12"];
}
```

However, this graph shows self-loops and multiple edges between the same node, which is not very informative. A more simplified version of the graph would be:

```
digraph CallGraph {
    node[shape=box];
    "_Z15smallest_changeSt6vectorIiSaIiEE" [label="_Z15smallest_changeSt6vectorIiSaIiEE"];
}
```

This graph simply shows that there is only one function in the call graph, which is `_Z15smallest_changeSt6vectorIiSaIiEE`.

Please note that the actual name of the function is `_Z15smallest_changeSt6vectorIiSaIiEE`, which is a mangled name generated by the C++ compiler. If you want to see the original name of the function, you may need to demangle it. 

Also, since there is only one function in the provided code, there are no other nodes to connect to in the call graph. If you provide more code with multiple functions, the call graph will show the connections between these functions.